%!TEX root = ../document.tex
\chapter{Implementation}\label{ch:implemenation}

\begin{quotation}
"Tiny modules built on other tiny modules to make tiny powerful high level abstractions".
{\small\it -- James Halliday (substack), founder of browserling, prolific Node.js developer}
\end{quotation}

During the process of developing browserCloud.js, several attempts were created following the Agile methodology, rapidly creating working prototypes and iterating over them. This led to the creation of several open source modules, MIT licensed, having been downloaded in the order of dozens of thousand times until the creation of this document.

Every code artifact was developed following the Unix philosophy, every module attempts to do at most one thing and one thing well, creating small, maintainable and powerful abstractions.

In this section, we describe the implementation details of the final code artifacts that compose the browserCloud.js and the collaterals designed and created that although not projected in the beginning, were needed in order to collect the data we were looking to study.

\section{Browser module}

explain how it was built
browserify
socket.io


\section{Signalling server}

websockets API
restful API


\section{Key learnings from the earlier iterations - webrtc-ring}

During one of the earlier iterations, we've developed a prototype of webrtc-explorer, called webrtc-ring, which although very similiar in routing strategy, each peer only knew about its successor, in another words, each peer only had access to one finger, this originated a system with the following properties:

\begin{itemize}
    \item overlay structure - 1 dimension Hash Ring
    \item lookup protocol - Matching key and NodeID
    \item network parameters - Number of Nodes in the network
    \item routing table size - 1
    \item routing complexity - O(log(N))
    \item join/leave overhead - 2
\end{itemize}

During the development, we performed tests to evaluate the capacity of the system to distribute work, later discussed on the Evaluation section. We learned that due to the single thread nature of Javascript, running message routing inside the same process that would be use to perform CPU bound tasks could be highly disavantageous for browserCloud.js performance. To overcome this, we introduced Web Workers to the system, independent threads inside the browser to separate communication from CPU bound tasks.

\section{Implementation collaterals}

During the development

\subsection{Testing browserCloud.js}

piri-piri


\subsection{Visualize the network state}

Using D3JS, a API library that works as a thin veneer on top of SVG, we've developed an application that grabs the state of the browserCloud.js network and shows a live graphical representation, as seen on Figure~\ref{fig:visualizer}, where each node is represented by a dot and its ID and the arcs being the connections established between the nodes in the network.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.8\textwidth]{figs/visualizer}
  \caption{Visualization of a browserCloud.js network}
  \label{fig:visualizer}
\end{figure}

\subsection{Simulate a browserCloud.js network}

In addition to the visualizer application, one simulator application was developed, were not only a graphical representation is generated, but also, it gives the developer a way to create a new virtual network, without any real peers. We've the option to pick the number of peers we want present and how many and which fingers will be used, so we can analyse different distribution paths and optimize for number of hops between any two peers in the network.

\subsection{Ray Tracing module}

To perform the parallel CPU bound tests, we've developed a module that works in Node.js and in the browser to perform Ray Tracing Tasks. The module works in a synchronous fashion so it performs faster, in another words, there are not techniques to make que module asynchronous that would create an overhead for the processing, in order to avoid stopping javascript event loop, the ray tracing task has to be ran in a sub process.

This module performs the interpretation of a scene designed in CSS, division of the scene in multiple parts (tasks) and reconstruction of the ray traced scene when every task is completed.

\section{Summary}


